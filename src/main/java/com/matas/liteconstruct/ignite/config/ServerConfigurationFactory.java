package com.matas.liteconstruct.ignite.config;

import java.sql.Types;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.UUID;
import javax.cache.configuration.Factory;
import javax.sql.DataSource;
import org.apache.ignite.Ignite;
import org.apache.ignite.Ignition;
import org.apache.ignite.cache.CacheAtomicityMode;
import org.apache.ignite.cache.CacheMode;
import org.apache.ignite.cache.QueryEntity;
import org.apache.ignite.cache.store.jdbc.CacheJdbcPojoStoreFactory;
import org.apache.ignite.cache.store.jdbc.JdbcType;
import org.apache.ignite.cache.store.jdbc.JdbcTypeField;
import org.apache.ignite.cache.store.jdbc.dialect.BasicJdbcDialect;
import org.apache.ignite.configuration.CacheConfiguration;
import org.apache.ignite.configuration.IgniteConfiguration;
import org.apache.ignite.spi.discovery.tcp.TcpDiscoverySpi;
import org.apache.ignite.spi.discovery.tcp.ipfinder.TcpDiscoveryIpFinderAdapter;
import org.apache.ignite.springdata20.repository.config.EnableIgniteRepositories;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Service;
import com.matas.liteconstruct.ignite.consulignite.TcpDiscoveryConsulIpFinder;
import com.matas.liteconstruct.ignite.model.ClassAccessRule;
import lombok.extern.slf4j.Slf4j;

/** This file was generated by Ignite Web Console (11/29/2019, 10:36) **/
@Slf4j
@Configuration
// @EnableIgniteRepositories
public class ServerConfigurationFactory {


  private DataSource dataSource;

  @Autowired
  public void setDataSource(DataSource dataSource) {
    this.dataSource = dataSource;
  }

  @Bean
  public Ignite igniteInstance() {
    try {
      return Ignition.start(createConfiguration());
    } catch (Exception e) {
      e.printStackTrace();
      return null;
    }
  }

  // @Autowired
  // AccessRuleIgniteRepository repository;

  // /** Secret properties loading. **/
  // private static final Properties props = new Properties();
  //
  // static {
  // try (InputStream in =
  // IgniteConfiguration.class.getClassLoader().getResourceAsStream("secret.properties")) {
  // props.load(in);
  // } catch (Exception ignored) {
  // // No-op.
  // }
  // }
  //
  // /** Helper class for datasource creation. **/
  // public static class DataSources {
  // public static final PGPoolingDataSource INSTANCE_dsPostgreSQL_ObjectCrm =
  // createdsPostgreSQL_ObjectCrm();
  //
  // private static PGPoolingDataSource createdsPostgreSQL_ObjectCrm() {
  // PGPoolingDataSource dsPostgreSQL_ObjectCrm = new PGPoolingDataSource();
  //
  // dsPostgreSQL_ObjectCrm.setUrl(props.getProperty("dsPostgreSQL_ObjectCrm.jdbc.url"));
  // dsPostgreSQL_ObjectCrm.setUser(props.getProperty("dsPostgreSQL_ObjectCrm.jdbc.username"));
  // dsPostgreSQL_ObjectCrm.setPassword(props.getProperty("dsPostgreSQL_ObjectCrm.jdbc.password"));
  //
  // return dsPostgreSQL_ObjectCrm;
  // }
  // }

  /**
   * Configure grid.
   * 
   * @return Ignite configuration.
   * @throws Exception If failed to construct Ignite configuration instance.
   **/
  public IgniteConfiguration createConfiguration() throws Exception {
    // log.info("start data source: {}", this.dataSource);
    IgniteConfiguration cfg = new IgniteConfiguration();

    cfg.setIgniteInstanceName("ImportedCluster");

    TcpDiscoverySpi discovery = new TcpDiscoverySpi();

    // TcpDiscoveryMulticastIpFinder ipFinder = new TcpDiscoveryMulticastIpFinder();
    //
    // ipFinder.setAddresses(Arrays.asList("127.0.0.1:47500..47510"));
    TcpDiscoveryIpFinderAdapter ipFinder = new TcpDiscoveryConsulIpFinder();

    ((TcpDiscoveryConsulIpFinder) ipFinder).setConsulPort(8500);
    ((TcpDiscoveryConsulIpFinder) ipFinder).setConsulAddres("http://192.168.99.101");

    discovery.setIpFinder(ipFinder);

    cfg.setDiscoverySpi(discovery);

    cfg.setCacheConfiguration(cacheClassAccessRuleCache());

    return cfg;
  }

  /**
   * Create configuration for cache "ClassAccessRuleCache".
   * 
   * @return Configured cache.
   * @throws Exception if failed to create cache configuration.
   **/
  public CacheConfiguration<UUID, ClassAccessRule> cacheClassAccessRuleCache() throws Exception {
    CacheConfiguration<UUID, ClassAccessRule> ccfg = new CacheConfiguration<>();
    // log.info("cacheClassAccessRuleCache data source: {}", this.dataSource);
    ccfg.setName("ClassAccessRuleCache");
    ccfg.setCacheMode(CacheMode.PARTITIONED);
    ccfg.setAtomicityMode(CacheAtomicityMode.ATOMIC);

    CacheJdbcPojoStoreFactory<UUID, ClassAccessRule> cacheStoreFactory =
        new CacheJdbcPojoStoreFactory<>();


    log.info("data source: {}", dataSource);
    // DataSourceBuilder dataSourceBuilder = DataSourceBuilder.create();
    // dataSourceBuilder.driverClassName("org.postgresql.Driver");
    // dataSourceBuilder.url("jdbc:postgresql://crm.invensio.com:5432/object_crm");
    // dataSourceBuilder.username("liteconstruct");
    // dataSourceBuilder.password("R2_;#fil!fI5");
    // cacheStoreFactory.setDataSource(dataSourceBuilder.build());
    // cacheStoreFactory.setDataSourceBean("pgDataSource");
    cacheStoreFactory.setDataSource(dataSource);

    // cacheStoreFactory.setDataSourceFactory(new Factory<DataSource>() {
    // /** {@inheritDoc} **/
    // @Override
    // public DataSource create() {
    // return DataSources.INSTANCE_dsPostgreSQL_ObjectCrm;
    // };
    // });

    cacheStoreFactory.setDialect(new BasicJdbcDialect());

    cacheStoreFactory.setTypes(jdbcTypeClassAccessRule(ccfg.getName()));

    ccfg.setCacheStoreFactory(cacheStoreFactory);

    ccfg.setReadThrough(true);
    ccfg.setWriteThrough(true);

    ArrayList<QueryEntity> qryEntities = new ArrayList<>();

    QueryEntity qryEntity = new QueryEntity();

    qryEntity.setKeyType("java.lang.UUID");
    qryEntity.setValueType("com.matas.liteconstruct.ignite.model.ClassAccessRule");
    qryEntity.setTableName("class_access_rule");
    qryEntity.setKeyFieldName("id");

    HashSet<String> keyFields = new HashSet<>();

    keyFields.add("id");

    qryEntity.setKeyFields(keyFields);

    LinkedHashMap<String, String> fields = new LinkedHashMap<>();

    fields.put("id", "java.util.UUID");
    fields.put("name", "java.lang.String");
    fields.put("companyId", "java.util.UUID");
    fields.put("classId", "java.util.UUID");
    fields.put("accessFilterGroupId", "java.util.UUID");
    fields.put("editAccess", "java.lang.Short");
    fields.put("priority", "java.lang.Integer");
    fields.put("levelAccess", "java.lang.Short");
    fields.put("levelValue", "java.lang.UUID");

    qryEntity.setFields(fields);

    HashMap<String, String> aliases = new HashMap<>();

    aliases.put("companyId", "company_id");
    aliases.put("classId", "class_id");
    aliases.put("accessFilterGroupId", "access_filter_group_id");
    aliases.put("editAccess", "edit_access");
    aliases.put("levelAccess", "level_access");
    aliases.put("levelValue", "level_value");

    qryEntity.setAliases(aliases);
    qryEntities.add(qryEntity);

    ccfg.setQueryEntities(qryEntities);

    return ccfg;
  }

  /**
   * Create JDBC type for "jdbcTypeClassAccessRule".
   * 
   * @param cacheName Cache name.
   * @return Configured JDBC type.
   **/
  private static JdbcType jdbcTypeClassAccessRule(String cacheName) {
    JdbcType type = new JdbcType();

    type.setCacheName(cacheName);
    type.setKeyType(UUID.class);
    type.setValueType("com.matas.liteconstruct.ignite.model.ClassAccessRule");
    type.setDatabaseSchema("public");
    type.setDatabaseTable("class_access_rule");

    type.setKeyFields(new JdbcTypeField(Types.OTHER, "id", UUID.class, "id"));

    type.setValueFields(new JdbcTypeField(Types.OTHER, "id", UUID.class, "id"),
        new JdbcTypeField(Types.VARCHAR, "name", String.class, "name"),
        new JdbcTypeField(Types.OTHER, "company_id", UUID.class, "companyId"),
        new JdbcTypeField(Types.OTHER, "class_id", UUID.class, "classId"),
        new JdbcTypeField(Types.OTHER, "access_filter_group_id", UUID.class,
            "accessFilterGroupId"),
        new JdbcTypeField(Types.SMALLINT, "edit_access", short.class, "editAccess"),
        new JdbcTypeField(Types.INTEGER, "priority", int.class, "priority"),
        new JdbcTypeField(Types.SMALLINT, "level_access", short.class, "levelAccess"),
        new JdbcTypeField(Types.OTHER, "level_value", UUID.class, "levelValue"));

    return type;
  }


}
